#!/usr/bin/env python3

"""
qBittorrent script to remove non-working trackers from torrents
Requires qBittorrent's Web UI to be enabled.
"""

import argparse
import getpass
import requests
import sys
from dataclasses import dataclass, replace
from typing import Any, Dict, List, Mapping, Sequence, cast

# Rely on requests' public API types to keep annotations accurate and Pylance happy.

# Fail fast when the Web UI port is closed, but allow a bit more time to read responses.
CONNECT_TIMEOUT_SECONDS = 5.0
READ_TIMEOUT_SECONDS = 30.0
REQUEST_TIMEOUT = (CONNECT_TIMEOUT_SECONDS, READ_TIMEOUT_SECONDS)


class ParsedArgs(argparse.Namespace):
    # Explicit CLI arg types make Pylance happy and document the expected inputs.
    url: str | None
    user: str | None
    ignore_invalid_ssl: bool
    include_private_torrents: bool


# Bundle CLI-derived settings so functions don't pass a long list of parameters.
@dataclass(frozen=True)
class CLIConfig:
    qbittorrent_url: str
    username: str
    password: str | None
    ignore_invalid_ssl: bool
    ignore_private_torrents: bool


class AuthenticationRequiredError(RuntimeError):
    """Raised when qBittorrent requires authentication."""


# Centralize qBittorrent API calls so URL construction and request handling are
# documented in one place and the higher-level logic stays easy to read.
@dataclass(frozen=True)
class QbittorrentClient:
    base_url: str
    session: requests.Session
    timeout: tuple[float, float]

    def _get(
        self, path: str, params: Mapping[str, Any] | None = None
    ) -> requests.Response:
        return self.session.get(
            f"{self.base_url}{path}", params=params, timeout=self.timeout
        )

    def _post(
        self, path: str, data: Mapping[str, Any] | None = None
    ) -> requests.Response:
        return self.session.post(
            f"{self.base_url}{path}", data=data, timeout=self.timeout
        )

    def login(self, username: str, password: str) -> None:
        # qBittorrent responds with HTTP 200 and body "Ok." on success.
        response = self._post(
            "/api/v2/auth/login", data={"username": username, "password": password}
        )
        ensure_success(
            response,
            "Login failed",
            "Authentication failed. Please provide qBittorrent credentials.",
        )
        if response.text != "Ok.":
            raise RuntimeError("Login failed: unexpected response from qBittorrent")

    def torrents(self) -> List[Dict[str, Any]]:
        response = self._get("/api/v2/torrents/info")
        ensure_success(
            response,
            "Failed to fetch torrents",
            "Authentication required to list torrents. Provide credentials.",
        )
        return cast(List[Dict[str, Any]], response.json())

    def trackers(self, torrent_hash: str) -> List[Dict[str, Any]]:
        response = self._get("/api/v2/torrents/trackers", params={"hash": torrent_hash})
        ensure_success(
            response,
            f"Failed to fetch trackers for torrent hash {torrent_hash}",
            "Authentication required to inspect trackers. Provide credentials.",
        )
        return cast(List[Dict[str, Any]], response.json())

    def remove_tracker(
        self, torrent_hash: str, tracker_url: str
    ) -> requests.Response:
        return self._post(
            "/api/v2/torrents/removeTrackers",
            data={"hash": torrent_hash, "urls": tracker_url},
        )

    def logout(self) -> None:
        try:
            self._post("/api/v2/auth/logout")
        except Exception:  # pragma: no cover - best effort cleanup
            pass


def build_parser() -> argparse.ArgumentParser:
    """Construct the argument parser for the CLI."""
    parser = argparse.ArgumentParser(
        description="Remove non-working trackers from qBittorrent torrents.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=(
            "If --url and --user are not provided, the script will prompt for them "
            "interactively."
        ),
    )
    parser.add_argument(
        "--url", type=str, help="qBittorrent Web UI URL (e.g., https://localhost:8080)"
    )
    parser.add_argument("--user", type=str, help="qBittorrent username")
    parser.add_argument(
        "--ignore-invalid-ssl",
        action="store_true",
        help="Ignore invalid SSL certificates.",
    )
    parser.add_argument(
        "--include-private-torrents",
        action="store_true",
        help="Include private torrents (by default, they are ignored).",
    )
    return parser


def prompt_for_credentials() -> CLIConfig:
    """Prompt interactively for qBittorrent connection details."""
    try:
        qbittorrent_url = input(
            "Enter qBittorrent Web UI URL (e.g., https://localhost:8080): "
        ).strip()
        username = input("Enter qBittorrent username: ").strip()
        password = getpass.getpass("Enter qBittorrent password: ")
    except KeyboardInterrupt as exc:
        print("\nOperation cancelled by user.")
        raise SystemExit(1) from exc

    return CLIConfig(
        qbittorrent_url=qbittorrent_url,
        username=username,
        password=password,
        ignore_invalid_ssl=False,
        ignore_private_torrents=True,
    )


def derive_config(parser: argparse.ArgumentParser) -> CLIConfig:
    """Derive the execution configuration from CLI arguments or prompts."""
    args = parser.parse_args(namespace=ParsedArgs())
    ignore_invalid_ssl = bool(args.ignore_invalid_ssl)
    ignore_private_torrents = not bool(args.include_private_torrents)

    if args.url and args.user:
        # Password can be prompted later if the Web UI requires authentication.
        return CLIConfig(
            qbittorrent_url=args.url,
            username=args.user,
            password=None,
            ignore_invalid_ssl=ignore_invalid_ssl,
            ignore_private_torrents=ignore_private_torrents,
        )

    if args.url or args.user:
        parser.error(
            "Both --url and --user must be provided together, or neither to use interactive prompts."
        )

    config = prompt_for_credentials()
    return replace(
        config,
        ignore_invalid_ssl=ignore_invalid_ssl,
        ignore_private_torrents=ignore_private_torrents,
    )


def prompt_for_password(username: str) -> str:
    """Prompt the user for a qBittorrent password."""
    prompt = "Enter qBittorrent password"
    if username:
        prompt += f" for {username}"
    prompt += ": "
    return getpass.getpass(prompt)


def create_session(ignore_invalid_ssl: bool) -> requests.Session:
    """Create a configured requests session."""
    session = requests.Session()
    session.verify = not ignore_invalid_ssl
    return session


def ensure_success(
    response: requests.Response,
    error_message: str,
    auth_error_message: str | None = None,
) -> None:
    """Raise an error if the response indicates a failure."""
    # qBittorrent uses 401/403 when authentication is required.
    if response.status_code in (401, 403):
        raise AuthenticationRequiredError(
            auth_error_message or "Authentication is required to access qBittorrent"
        )
    if response.status_code != 200:
        raise RuntimeError(error_message)


def tracker_is_not_working(tracker: Dict[str, Any]) -> bool:
    """Return True if a tracker is reported as not working."""
    # qBittorrent reports tracker status=4 as "Not working".
    return int(tracker.get("status", 0)) == 4


def remove_tracker_from_torrent(
    client: QbittorrentClient,
    torrent_hash: str,
    tracker_url: str,
    torrent_name: str,
) -> bool:
    """Remove a tracker from a torrent, retrying once if necessary."""
    response = client.remove_tracker(torrent_hash, tracker_url)
    if response.status_code != 200:
        print(f"Failed to remove tracker {tracker_url} from torrent {torrent_name}")
        return False

    try:
        updated_trackers = client.trackers(torrent_hash)
    except RuntimeError:
        print(f"Failed to re-check trackers for torrent: {torrent_name}")
        return False

    if any(str(t.get("url", "")) == tracker_url for t in updated_trackers):
        print(
            f"Tracker {tracker_url} still exists for torrent {torrent_name}, retrying..."
        )
        retry_response = client.remove_tracker(torrent_hash, tracker_url)
        if retry_response.status_code != 200:
            print(f"Retry failed for tracker {tracker_url} on torrent {torrent_name}")
            return False

    return True


def process_torrents(
    client: QbittorrentClient, config: CLIConfig, torrents: Sequence[Dict[str, Any]]
) -> int:
    """Remove dead trackers from torrents and return the number of actions performed."""
    actions_performed = 0
    for torrent in torrents:
        torrent_hash = str(torrent.get("hash", "")).strip()
        torrent_name = str(torrent.get("name", "Unnamed torrent"))

        if not torrent_hash:
            print(f"Skipping torrent with missing hash: {torrent_name}")
            continue

        if config.ignore_private_torrents and bool(torrent.get("is_private", False)):
            # Many private trackers disallow tampering with the tracker list.
            print(f"Skipping private torrent: {torrent_name}")
            continue

        try:
            trackers = client.trackers(torrent_hash)
        except AuthenticationRequiredError as exc:
            print(exc)
            raise
        except RuntimeError as exc:
            print(exc)
            continue

        # Only remove trackers qBittorrent already marked as non-working.
        non_working_trackers = [
            tracker for tracker in trackers if tracker_is_not_working(tracker)
        ]

        for tracker in non_working_trackers:
            tracker_url = str(tracker.get("url", "")).strip()
            if not tracker_url:
                continue

            print(f"Removing tracker {tracker_url} from torrent {torrent_name}")
            if remove_tracker_from_torrent(
                client, torrent_hash, tracker_url, torrent_name
            ):
                actions_performed += 1
    return actions_performed


def login_with_prompt(client: QbittorrentClient, config: CLIConfig) -> CLIConfig:
    password = prompt_for_password(config.username)
    updated = replace(config, password=password)
    client.login(updated.username, password)
    return updated


def main() -> None:
    """Script entry point."""
    parser = build_parser()
    config = derive_config(parser)
    session = create_session(config.ignore_invalid_ssl)
    client = QbittorrentClient(config.qbittorrent_url, session, REQUEST_TIMEOUT)

    try:
        if config.password is not None:
            client.login(config.username, config.password)

        try:
            torrents = client.torrents()
        except AuthenticationRequiredError:
            if config.password is not None:
                raise

            # Defer password prompts until qBittorrent explicitly asks for auth.
            config = login_with_prompt(client, config)
            torrents = client.torrents()

        try:
            actions_performed = process_torrents(client, config, torrents)
        except AuthenticationRequiredError:
            if config.password is not None:
                raise

            # If auth expires mid-run, prompt once more and retry the full pass.
            config = login_with_prompt(client, config)
            torrents = client.torrents()
            actions_performed = process_torrents(client, config, torrents)

        if actions_performed == 0:
            print(
                "No actions were performed. All trackers are functional or private torrents were skipped."
            )
    except requests.exceptions.ConnectTimeout:
        print(
            f"Timed out connecting to qBittorrent at {config.qbittorrent_url} "
            f"after {CONNECT_TIMEOUT_SECONDS:.0f} seconds. "
            "Check if the Web UI is running and the port is reachable."
        )
        sys.exit(1)
    except requests.exceptions.ReadTimeout:
        print(
            f"qBittorrent at {config.qbittorrent_url} took too long to respond "
            f"(>{READ_TIMEOUT_SECONDS:.0f} seconds). "
            "Check if the Web UI is responsive."
        )
        sys.exit(1)
    except requests.exceptions.Timeout:
        print(
            f"Request to qBittorrent at {config.qbittorrent_url} timed out. "
            "Check the Web UI connectivity."
        )
        sys.exit(1)
    except requests.exceptions.ConnectionError:
        print(
            f"Failed to connect to qBittorrent at {config.qbittorrent_url}. "
            "Check if the Web UI is enabled and reachable."
        )
        sys.exit(1)
    except AuthenticationRequiredError as exc:
        print(exc)
        sys.exit(1)
    except RuntimeError as exc:
        print(exc)
        sys.exit(1)
    finally:
        client.logout()


if __name__ == "__main__":
    main()
