#!/usr/bin/env python3

"""
DNS Propagation Checker with Public DNS Resolvers and Threading
---------------------------------------------------------------
Purpose:
    This script checks DNS propagation for specified domains by querying multiple public DNS resolvers.
    It queries each resolver for specific DNS record types using threading for improved performance.

Usage:
    flushdns --types=A,NS,CNAME example.com example.net
    flushdns --types=A example.org
    flushdns example.net  # defaults to A records
"""

import argparse
import importlib
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from typing import List

dns_resolver = importlib.import_module("dns.resolver")
dns_exception = importlib.import_module("dns.exception")

# ANSI color codes for formatting output
RESET = "\033[0m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
ORANGE = "\033[38;5;208m"
CYAN = "\033[96m"
RED = "\033[91m"

DEFAULT_RECORD_TYPES = ["A"]


@dataclass(frozen=True)
class ResolverInfo:
    address: str
    description: str


# Public DNS servers for querying
PUBLIC_DNS_SERVERS = [
    ResolverInfo("8.8.8.8", "Google Public DNS"),
    ResolverInfo("8.8.4.4", "Google Public DNS"),
    ResolverInfo("1.1.1.1", "Cloudflare DNS"),
    ResolverInfo("1.0.0.1", "Cloudflare DNS"),
    ResolverInfo("9.9.9.9", "Quad9"),
    ResolverInfo("149.112.112.112", "Quad9"),
    ResolverInfo("208.67.222.222", "OpenDNS (Cisco Umbrella)"),
    ResolverInfo("208.67.220.220", "OpenDNS (Cisco Umbrella)"),
    ResolverInfo("94.140.14.14", "AdGuard DNS"),
    ResolverInfo("94.140.15.15", "AdGuard DNS"),
    ResolverInfo("94.140.14.140", "AdGuard DNS (Non-filtering)"),
    ResolverInfo("94.140.14.141", "AdGuard DNS (Non-filtering)"),
    ResolverInfo("76.76.2.0", "Control D Free"),
    ResolverInfo("76.76.10.0", "Control D Free"),
    ResolverInfo("64.6.64.6", "Vercara UltraDNS Public"),
    ResolverInfo("64.6.65.6", "Vercara UltraDNS Public"),
    ResolverInfo("156.154.70.2", "Vercara UltraDNS Threat Protection"),
    ResolverInfo("156.154.71.2", "Vercara UltraDNS Threat Protection"),
    ResolverInfo("185.222.222.222", "DNS.SB"),
    ResolverInfo("45.11.45.11", "DNS.SB"),
]


def parse_record_types(raw_types: List[str]) -> List[str]:
    """
    Parse comma-separated record type arguments into a normalized list.
    """
    if not raw_types:
        return DEFAULT_RECORD_TYPES.copy()

    record_types: List[str] = []
    for entry in raw_types:
        for candidate in entry.split(","):
            normalized = candidate.strip().upper()
            if normalized and normalized not in record_types:
                record_types.append(normalized)

    return record_types or DEFAULT_RECORD_TYPES.copy()


@dataclass
class DNSQueryResult:
    """Stores DNS query results for easy access and formatting."""

    domain: str
    dns_server: str
    description: str
    record_type: str
    status: str
    output: str


def dns_query(domain: str, resolver_info: ResolverInfo, record_type: str) -> DNSQueryResult:
    """
    Perform a DNS query for a specific record type using dnspython.
    """
    resolver = dns_resolver.Resolver()
    resolver.nameservers = [resolver_info.address]
    resolver.timeout = 3
    resolver.lifetime = 5

    try:
        answers = resolver.resolve(domain, record_type)
        output = "\n".join(str(answer) for answer in answers)
        print(
            f"{GREEN}SUCCESS{RESET}: {domain:<25} | {resolver_info.address:<15} | {record_type:<10}"
        )
        return DNSQueryResult(
            domain,
            resolver_info.address,
            resolver_info.description,
            record_type,
            "Success",
            output,
        )
    except dns_resolver.NoAnswer:
        print(
            f"{YELLOW}WARNING{RESET}: {domain:<25} | {resolver_info.address:<15} | {record_type:<10} | No answer found"
        )
        return DNSQueryResult(
            domain,
            resolver_info.address,
            resolver_info.description,
            record_type,
            "Failure",
            "No answer",
        )
    except dns_resolver.NXDOMAIN:
        print(
            f"{RED}ERROR{RESET}: {domain:<25} | {resolver_info.address:<15} | {record_type:<10} | Domain does not exist"
        )
        return DNSQueryResult(
            domain,
            resolver_info.address,
            resolver_info.description,
            record_type,
            "Failure",
            "NXDOMAIN",
        )
    except dns_resolver.Timeout:
        print(
            f"{RED}ERROR{RESET}: {domain:<25} | {resolver_info.address:<15} | {record_type:<10} | Query timed out"
        )
        return DNSQueryResult(
            domain,
            resolver_info.address,
            resolver_info.description,
            record_type,
            "Failure",
            "Timeout",
        )
    except dns_exception.DNSException as e:
        short_error = str(e).split(":")[-1].strip()
        print(
            f"{RED}ERROR{RESET}: {domain:<25} | {resolver_info.address:<15} | {record_type:<10} | {short_error}"
        )
        return DNSQueryResult(
            domain,
            resolver_info.address,
            resolver_info.description,
            record_type,
            "Failure",
            short_error,
        )


def run_dns_queries(
    domains: List[str],
    resolvers: List[ResolverInfo],
    record_types: List[str],
    max_workers: int = 10,
) -> List[DNSQueryResult]:
    """
    Run DNS queries concurrently for each domain against each DNS server and record type.
    """
    results: List[DNSQueryResult] = []
    total_queries = len(domains) * len(resolvers) * len(record_types)
    completed_queries = 0

    print(
        f"{CYAN}Starting DNS propagation checks for {len(domains)} domain(s)...{RESET}"
    )

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_query = {
            executor.submit(dns_query, domain, resolver, record_type): (
                domain,
                resolver,
                record_type,
            )
            for domain in domains
            for resolver in resolvers
            for record_type in record_types
        }

        for future in as_completed(future_to_query):
            try:
                result = future.result()
                results.append(result)
            except Exception as e:
                domain, resolver, record_type = future_to_query[future]
                print(
                    f"{RED}ERROR{RESET}: {domain:<25} | {resolver.address:<15} | {record_type:<10} | Exception: {str(e)}"
                )
            finally:
                completed_queries += 1
                print(
                    f"{CYAN}Progress:{RESET} {completed_queries}/{total_queries} queries completed.",
                    end="\r",
                )

    print()  # Move to the next line after progress
    return results


def print_summary(results: List[DNSQueryResult]) -> None:
    """
    Print a summary table of the DNS query results.
    """
    headers = ["Domain", "DNS Server", "Description", "Record Type", "Status"]
    rows: List[List[str]] = [
        [
            result.domain,
            result.dns_server,
            result.description,
            result.record_type,
            result.status,
        ]
        for result in results
    ]

    column_values = [headers] + rows
    widths = [
        max(len(value) for value in (column[idx] for column in column_values)) + 1
        for idx in range(len(headers))
    ]

    header = " | ".join(
        f"{headers[idx]:<{widths[idx]}}" for idx in range(len(headers))
    )
    print(f"\n{CYAN}Summary Table:{RESET}")
    print(header)
    print("-" * len(header))
    for result in results:
        status_color = (
            GREEN
            if result.status == "Success"
            else (YELLOW if result.status == "No answer" else RED)
        )
        row = [
            result.domain,
            result.dns_server,
            result.description,
            result.record_type,
            result.status,
        ]
        formatted_values: List[str] = []
        for idx, value in enumerate(row):
            formatted = f"{value:<{widths[idx]}}"
            if idx == 4:
                formatted = f"{status_color}{formatted}{RESET}"
            formatted_values.append(formatted)

        summary_line = " | ".join(formatted_values)
        print(summary_line)


def main():
    parser = argparse.ArgumentParser(
        description="Check DNS propagation across multiple public resolvers."
    )
    parser.add_argument(
        "-t",
        "--types",
        action="append",
        help="Comma-separated DNS record types to query (can be provided multiple times).",
        default=[],
    )
    parser.add_argument(
        "domains",
        nargs="+",
        help="One or more domain names to query.",
    )

    args = parser.parse_args()
    record_types = parse_record_types(args.types)

    results = run_dns_queries(args.domains, PUBLIC_DNS_SERVERS, record_types)
    print_summary(results)


if __name__ == "__main__":
    main()
